package services

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"
)

// Structs to represent request and response payloads
type ChatGPTRequest struct {
	Model    string    `json:"model"`
	Messages []Message `json:"messages"`
}

// Message here represents a chat message formatted for openai api
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ChatGPTResponse struct {
	Choices []Choice `json:"choices"`
}

type Choice struct {
	Message Message `json:"message"`
}

// é¢„è®¾çš„æ¨¡æ‹Ÿå“åº”
var mockResponses = []string{
	"Hello! I'm a chatbot powered by AI. How can I help you today?",
	"That's an interesting question! Let me think about that for you.",
	"I understand what you're asking. Here's my perspective on that topic.",
	"Thanks for your message! I'm here to assist you with any questions you have.",
	"That's a great question! I'd be happy to help you with that.",
	"I appreciate you reaching out. Let me provide some helpful information.",
	"Excellent question! I can definitely help you understand that better.",
	"I see what you're getting at. Here's what I think about that topic.",
	"Thanks for asking! That's something I can certainly help explain.",
	"I'm glad you brought that up! Let me share some insights with you.",
}

// æ ¹æ®ç”¨æˆ·è¾“å…¥ç”Ÿæˆç›¸åº”çš„æ¨¡æ‹Ÿå“åº”
func generateMockResponse(userMessage string) string {
	// åˆå§‹åŒ–éšæœºæ•°ç”Ÿæˆå™¨
	rand.Seed(time.Now().UnixNano())
	
	userLower := strings.ToLower(userMessage)
	
	// æ ¹æ®ç”¨æˆ·è¾“å…¥çš„å…³é”®è¯è¿”å›ç‰¹å®šå“åº”
	if strings.Contains(userLower, "math") || strings.Contains(userLower, "+") || strings.Contains(userLower, "-") || strings.Contains(userLower, "*") || strings.Contains(userLower, "/") {
		return "I see you're asking about math! Mathematics is a fascinating subject that helps us understand patterns and solve problems."
	}
	
	if strings.Contains(userLower, "hello") || strings.Contains(userLower, "hi") || strings.Contains(userLower, "hey") {
		return "Hello there! It's great to meet you. I'm an AI assistant ready to help with your questions."
	}
	
	if strings.Contains(userLower, "what") || strings.Contains(userLower, "how") || strings.Contains(userLower, "why") {
		return "That's a thoughtful question! I'd be happy to help explain that topic to you."
	}
	
	if strings.Contains(userLower, "help") {
		return "I'm here to help! Feel free to ask me about any topic you're curious about."
	}
	
	// é»˜è®¤è¿”å›éšæœºå“åº”
	return mockResponses[rand.Intn(len(mockResponses))]
}

// GetChatGPTResponse interacts with the OpenAI API and retrieves the response
func GetChatGPTResponse(message string) (string, error) {
	//load api from environment
	apiKey := os.Getenv("OPENAI_API_KEY")
	log.Printf("ğŸ”‘ Loaded API Key: %s", apiKey[:20]+"...") // åªæ˜¾ç¤ºå‰20ä¸ªå­—ç¬¦ä¿æŠ¤éšç§
	if apiKey == "" {
		log.Println("âŒ ERROR: OPENAI_API_KEY is not set!")
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”è€Œä¸æ˜¯é”™è¯¯
	}

	// OpenAI API URL
	apiURL := "https://api.openai.com/v1/chat/completions"

	// Construct the request payload
	requestPayload := ChatGPTRequest{
		Model: "gpt-4",
		Messages: []Message{
			{Role: "user", Content: message},
		},
	}

	// Serialize the request payload to JSON
	requestBody, err := json.Marshal(requestPayload)
	if err != nil {
		log.Printf("âŒ Failed to marshal request payload: %v", err)
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}

	log.Printf("ğŸ“¤ Sending request to OpenAI: %s", string(requestBody))

	// Create the HTTP request
	req, err := http.NewRequest("POST", apiURL, bytes.NewBuffer(requestBody))
	if err != nil {
		log.Printf("âŒ Failed to create HTTP request: %v", err)
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}

	// Set headers
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	log.Printf("ğŸŒ Making HTTP request to: %s", apiURL)

	// Make the HTTP request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("âŒ Failed to make HTTP request: %v", err)
		log.Printf("ğŸ”„ Falling back to mock response")
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}
	defer resp.Body.Close()

	log.Printf("ğŸ“‹ Response Status Code: %d", resp.StatusCode)
	log.Printf("ğŸ“‹ Response Headers: %v", resp.Header)

	// Read the response body
	responseBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Printf("âŒ Failed to read response body: %v", err)
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}

	log.Printf("ğŸ“¥ Raw response body: %s", string(responseBody))

	// Check for API errors
	if resp.StatusCode != http.StatusOK {
		log.Printf("âŒ OpenAI API returned %d: %s", resp.StatusCode, string(responseBody))
		log.Printf("ğŸ”„ Falling back to mock response")
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}

	// Parse the response JSON
	var chatResponse ChatGPTResponse
	err = json.Unmarshal(responseBody, &chatResponse)
	if err != nil {
		log.Printf("âŒ Failed to unmarshal response: %v", err)
		log.Printf("âŒ Response body was: %s", string(responseBody))
		return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
	}

	log.Printf("ğŸ” Parsed response: %+v", chatResponse)
	log.Printf("ğŸ” Number of choices: %d", len(chatResponse.Choices))

	// Return the content of the first choice
	if len(chatResponse.Choices) > 0 {
		content := chatResponse.Choices[0].Message.Content
		log.Printf("âœ… Extracted content: '%s'", content)
		log.Printf("âœ… Content length: %d", len(content))
		return content, nil
	}

	log.Printf("âŒ No choices found in response")
	log.Printf("ğŸ”„ Falling back to mock response")
	return generateMockResponse(message), nil // è¿”å›æ¨¡æ‹Ÿå“åº”
}
